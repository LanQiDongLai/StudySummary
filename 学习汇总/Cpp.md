### 如何消除隐式转换？
在类类型转化中，使用explicit（清晰的）在构造函数之前会消除隐式转换
```cpp
class A{
public:
    int val;
    explicit A(int val){
        this->val = val;
    }
};
/////////////////////////////////
A a = 1;//报错，无法从int类型转化为A类型
        //如果取消explicit修饰符，那么编译器自动将该语句转化为
        //A a = A(1);
//这样做的好处是，防止代码中因为隐式转化而在构造、传参过程中发生不必要的误解
```
### 重载，重写和隐藏的区别？
1. 重载是全局或同类中的行为，如果同名函数具有不同的参数列表，那么在调用函数时传入不同的函数参数，则编译器会自动对应到与之匹配的函数参数
2. 重写是父类与子类之间的行为，当父类中定义虚函数，同时子类定义同名的虚函数（参数列表一致），那么子类生成的对象就会覆盖原来的父类的函数
3. 隐藏是指不同类中，或者是不同的命名空间，在该类中调用此函数，与别的类中的同名函数是没有任何干系的
4. 重定义（隐藏），父类中的成员函数在子类中有相同名称的定义（参数列表可以不同），那么父类中的成员函数就会被隐藏，只有显式的定义才会调用父类的函数
```cpp
//重定义
class A{
public:
    void func();
};
class B: public A{
public:
    void func(int val);
};

B b;
b.func();//出错，没有匹配参数列表
b.A::func();//正确，显式的调用父类函数
```
### volatile表示什么？有什么作用？ 
volatile用来表示这个变量的值随时都有可能会改变，不要将此值传进寄存器来优化
```cpp
volatile bool flag = true;
while(flag){//不加volatile，编译器可能会将此处直接优化为while(true)
    //...
}
//Other Thread
flag = false;
```
例如，在多线程环境中，一个线程中的值似乎不会发生任何改变，编译器可能会选择将上下文中所有用到此变量优化到寄存器中，那么其他线程想要改变该值，就会在结果上发生错误

### static_cast<>,dynamic_cast<>,const_cast<>,reinterpret_cast<>的各自作用和使用环境？
1. static_cast
   1. static_cast类似与强制类型转换，但是，static_cast不会去去除const属性，volatile属性，将值类型转化为指针类型，指针类型转为值类型
   2. 可以转换基础数据类型，int，float，double，char
   3. 可以转化指针/引用，但是两个指针/引用之间所属类型必须有着继承关系
   4. 可以将任何类型的指针转化为void *，void *转化为任何类型的指针
2. dynamic_cast
   1. 只能用于指针和引用，指针只能转化为指针，引用只能转化为引用
   2. 对于转化的类型必须具有虚函数表
   3. 会进行下行转化的检查，查看该父类指针是否可以转化为子类指针（检查是否在初始化时为子类），若不能，则返回为空指针
   4. 交叉转化的时候，dynamic_cast是允许的，但是static_cast是会在编译时期报错，结果返回为空指针
3. const_cast
   1. 用于将有const和volatile修饰的指针或变量转化为没有const和volatile修饰的指针或变量
   2. 只能传递指针或引用
   3. 只能调节限定符，不能更改类型
4. reinterpret_cast
   1. 仅仅只是处理对于指针所指向的值的一种映射，将指针所指空间的二进制数据强行转化为其他类型指针所指向的空间
   2. 只能传递指针或引用
   3. 所有转换中最危险的，相当与全部转化为(void*)再转化成其他类型
### malloc和new的区别？
1. malloc概念上是对内存空间的分配，按照字节数分配内存，new是对类型的分配，按照类型创建内存空间，同时会调用构造函数
2. malloc使用free释放内存，new使用delete释放内存
3. 当malloc调用失败的时候会返回NULL，而new会抛出bad_alloc异常
4. malloc会在堆上创建内存，new会在自由存储区（编译器一般作为堆区）上存储内存
5. new，new[]可以重载
### free和delete的区别？
1. free对应malloc分配的内存，delete对应new分配的内存
2. delete\[\]会对应new\[\]分配的内存
3. delete，delete[]可以重载
### free一个数组时如何知道要释放多大的内存呢？
在malloc时，会在返回的内存空间前面加上头部，其中保存了分配内存大小的信息，在调用free时，可以在指针的前几位中找到内存块大小，会将malloc头部和内存块一同释放
### __stdcall和__cdecl的区别？
不同点：  
__stdcall由被调用者返回时自动将参数从栈空间中清除，__cdecl由调用者将参数从栈空间中清除  
由于__cdecl是由调用者将参数从栈中清除，所以在使用变参函数时，必须使用此函数调用方法  
相同点：参数都是从右向左入栈
### linux内部提供了那些调试宏？
    __TIME__       显示当前时间    类型%s  
    __FILE__       显示当前文件    类型%s  
    __DATE__       显示当前日期    类型%s  
    __LINE__       显示当前行数    类型%d  
    __FUNCTION__   显示当前函数    类型%s  
### 引用和指针的区别？
1. 引用初始化的时候总是需要绑定一个对象或变量，所以不存在空引用或野引用，但是指针存在野指针或空指针，故引用相对更安全
2. 引用绑定一个变量或者对象之后就不能再改变，而指针可以再指向下一个对象，故指针更灵活
3. 有些时候，一个「引用」不会在被创建时就已经指向一个确定的对象，如链表或单例模式中的实例，在这种不是第一时间绑定的「引用」必须使用指针
4. 编译器在处理引用的大小(sizeof)的时候，会获取所引用的对象的大小，而指针只能获取其指针的大小(32位4字节，64位8字节)
5. 引用相当于Type* const(指针常量)
### 出现异常时，try和catch做了什么？ 
try中语句中发生异常时，catch会捕捉到该异常，并终止try中后续语句的执行，跳转到catch中的语句来执行
### C++如何处理多个异常的？常对象的成员变量一定不可以修改吗？为什么？
1. catch后括号中写上异常类型，当该类型异常抛出时，就由该catch语句块来执行，当括号中为三个点时，表示捕捉所有异常
2. 不一定，当常对象成员变量存储在常量区中，那么该成员不可修改，如果该成员是由C++标识符const所修饰的时候，那么他实际上是在栈区中，可以通过const_cast绕过编译器检查进行修改
### 虚函数的调用过程？
在具有虚函数的对象中存在一块指向虚函数表的指针，在调用虚函数时，会使用指针所指向的虚函数表，通过查询可以得到函数实例
### 单继承，多继承，菱形继承，虚继承时，对象内存中的差异区别？如果存在虚函数呢？
[](https://www.likecs.com/show-204168790.html)
### map底层用了什么？
红黑树和pair键值对
### 如果用map删除了一个元素，迭代器还能用吗？为什么？怎样做可以接着用？
不可以，因为迭代器所指向的红黑树节点被删除，红黑树也会出现相应的调整，所以迭代器失效  
erase方法会返回下一个节点的迭代器
### C++内置的std::sort是如何进行排序的
C++内置的sort函数是基于快速排序（Quick Sort）和插入排序（Insertion Sort）的混合排序（Hybrid Sort）算法。具体来说，当数组大小小于某个阈值（默认为16）时，sort函数采用插入排序进行排序；当数组大小大于等于阈值时，sort函数采用快速排序进行排序。此外，sort函数还实现了一些优化策略，如三点取中法（Median-of-Three Partitioning）选择枢轴，以及尾递归优化等，进一步提高了算法的效率。
### 对一个数组而言，delete a和delete[] a有什么区别？为什么？ 
在gcc编译器中，因为空间释放和调用析构函数所使用的机制并不相同，所以delete和delete[\]都会直接将所有的空间全部释放完毕，但是delete只会调用数组中第一个元素的析构函数，而delete[\]则会按照数组大小依次调用所有的析构函数  
在C++标准中，并没有规定此种行为，对于使用new分配的空间，使用delete[\]释放和使用new[\]分配的空间，使用delete释放，其结果都是未定义的
### dynamic_cast是如何实现运行时类型转换的？ 
dynamic_cast的实现原理如下：  
1. 在编译期，dynamic_cast会先判断源类型和目标类型是否存在继承或虚拟继承关系。如果不存在，则无法进行转换。
2. 在运行期，dynamic_cast会根据待转换的指针所指向的虚函数表与目标虚函数表进行比对，如果是同一虚函数表，那么转换成功。如果不是，那么返回nullptr。
### struct{char a\[0\];}的作用？有什么好处？
可以用来作为柔性数组，虽然此结构体占用空间为0字节，但是如果使用malloc或new分配内存时分配size长度的字节数，那么该结构体的a数组就指向那么长度的单元
```cpp
struct Array{
    int size;
    char a[0];
}
int main(){
    //初始化
    Array *ptr = (Array *)new char[sizeof(Array) + 100 * sizeof(char)];
    ptr->size = 100;
    /* 内存布局 */
    //ptr-> |size|(Array)
    //      |char a[0]|
    //      |char a[1]|
    //      ...
    //      |char a[100]|
}
```
### 变量的存储方式有哪些？
| 存储类别 | 描述 | 存储期 | 作用域 | 声明方式 | 
| ------ | --- | ----- | ----- | ------- |
| auto | 栈或堆变量 | 自动 | 块 | 块内 |
| register | 寄存器变量 | 自动 | 块 | 块内使用关键字register |
| static(局部) | 局部静态变量 | 静态 | 块 | 块内使用关键字static |
| static(全局) | 全局变量 | 文件内部 | 所有函数外使用关键字static |
| extern | 外部变量 | 静态 | 文件外部 | 所有函数外 |
### C++中有哪些机制可以取代宏？
常量使用const替代实现  
类型使用using替代实现  
函数或代码块使用inline替代实现
### C++中可以继承string类吗？为什么？
可以被继承，这不是Java  
C++ 可以使用final关键字防止类被继承
### char \* const \*(\*next)()是什么？
一个指向返回值为char *const *，参数为空的函数指针
### 如何判断const所修饰的对象？ 
对于修饰普通类型
```cpp
const int val = 5;
//表示该类型之后所占空间内容不可再改变  
```
对于修饰指针变量
```cpp
//const在*左边表示修饰指针所指向的类型为常量
const int *pval = 5;
int const *pval = 5;
*pval = 10;/*error*/
//const在*右边表示修饰指针的值不可改变，不能再指向一块新的空间地址
int *const pval = 5;
pval = nullptr;/*error*/
```
### C++中内存分为哪几部分？
1. 栈区：存放函数参数，局部变量，还有函数返回地址
2. 堆区：存放动态分配的内存，堆区的内存需要自己手动申请和释放，需要程序员自己管理
3. 全局区：存放全局变量、静态变量以及常量，全局区的大小在程序运行前就已经确定好
4. 代码区（只读区，常量区）：存放程序指令（包括静态链接库中函数实现），在程序运行前就已经分配好
### 如果new申请内存失败了，如何去解决？如果让你实现一个new，你会怎么实现？
1. 当new内存分配失败了会抛出std::bad_alloc异常，可以通过捕获该异常来处理，处理方式按照具体情况来
2. 如果申请内存失败需要返回空指针而不是抛出异常，可以使用new(std::nothrow)代替
3. new是有编译器支持的关键字，如果只是在现有的语法基础上实现基础的内存申请功能，但是自动调用构造函数无法实现，但是可以使用placement new来对已经存在的空间进行构造函数的调用
### 如何得到一个结构体内成员的偏移量？
```cpp
/* 直接用0作为结构体地址然后取变量的地址 */
(size_t)&((struct Node*)0)->val;
/* 使用库函数 */
#include <stddef.h>
offsetof(struct stru, i);
```
### 构造函数能不能虚函数？为什么？那拷贝构造函数能不能为虚函数？为什么？
虚函数是在运行时通过指针或引用来调用的，而构造函数在对象创建时自动调用，还没有创建出对象，因此不能通过指针或引用来调用。  
另外，构造函数的主要作用是初始化对象的成员变量，它在对象创建时调用，因此不存在多态的问题。
拷贝构造函数和构造函数是一个性质的问题，当然不能声明为虚构函数
### 析构函数能不能虚函数？为什么？
可以，使用虚析构函数可以让指向派生类的基类指针能够释放派生类所需要释放的资源
### 模板和实现可不可以不写在一个文件里面？为什么？
不可以，必须写在同一个文件里面    
C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的  
所有模板的类或函数的行为，都是在编译之后的实现中确定，相同的模板类或函数的不同实例在底层实现中都对应着不同的函数和类