### 构造函数运行的过程

<img src="/home/LanQiDongLai/.config/Typora/typora-user-images/image-20230820214822793.png" alt="image-20230820214822793" style="zoom:80%;" />

<img src="/home/LanQiDongLai/.config/Typora/typora-user-images/image-20230820214640440.png" alt="image-20230820214640440" style="zoom:80%;" />

首先开辟栈空间

将对象指针的值保存在栈空间的0～7字节，作为this指针（也就是说构造函数是有传入参数的，参数就是对象的地址）

将this指针保存到rax寄存器中

调用父类的构造函数（用this指针进行构造，多继承会根据父类的大小进行偏移）

将对象的的虚函数表地址保存到this指针所指向空间的0～7字节

将对象初始化列表的值按次序保存到this指针所指向空间的m~n字节

执行构造函数函数体

### 虚函数表构建与调用

虚函数表同一个类的实例所共享的资源，虚函数表在编译时候确定，并存在于常量区中，如果代码中没有该类的实例，那么编译器不会生成该函数表

虚函数的调用过程

其中-0x8($rbp)存储了&node

<img src="/home/LanQiDongLai/.config/Typora/typora-user-images/image-20230820220120063.png" alt="image-20230820220120063" style="zoom:80%;" />

> 注：编译器是根据函数名查找虚函数表的
>
> 编译器会将所有的虚函数指针按照一定排版放入虚函数表中（一般按照声明顺序），然后子类继承的时候也会按照相同的顺序放入虚函数表，在调用中，函数名会根据编译器内部保存的表转变成虚函数表的索引

虚函数表的结构

<img src="https://img-blog.csdn.net/20160528104806455" alt="这里写图片描述" style="zoom:80%;" />

<img src="https://img-blog.csdnimg.cn/img_convert/a13123af4c1a645bdd8288dbc44c6cd1.png" alt="image-20211203111747442" style="zoom:80%;" />

### gcc内嵌汇编

示例

```cpp
int return4(){
    int res;
    __asm__ __volatile__(
        "movl $4, %0\n\
        "
        :"=m"(res)
        :"%0"
    );
    return res;
}
```

格式

```cpp
__asm__ [__volatile__](
    "asm"									//汇编代码指令部分
    :"{m}{k}"(output), "{m}{k}"(output), ...//输出存储器
    [:"{k}"(input), "{k}"(input), ...]		//输入存储器（可选）
    [:["{r}", "{r2}", ..., "{rn}"]]			//被修改的存储器列表（可选）
)
```

\_\_asm\_\_ 标识后面的代码是内嵌汇编

\_\_volatile\_\_ 表示编译器不要优化内嵌汇编代码

对于{m}，和{k}的值，具体[详见](https://zhuanlan.zhihu.com/p/578286784)

```text
通用寄存器：
"a"               将输入变量放入eax
"b"               将输入变量放入ebx
"c"               将输入变量放入ecx
"d"               将输入变量放入edx
"s"               将输入变量放入esi
"d"               将输入变量放入edi
"q"               将输入变量放入eax，ebx，ecx，edx中的一个
"r"               将输入变量放入通用寄存器，也就是eax，ebx，ecx，edx，esi，edi中的一个
"A"              把eax和edx合成一个64 位的寄存器(use long longs)

内存：

"m"              内存变量
"o"              操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址
"V"              操作数为内存变量，但寻址方式不是偏移量类型
" "              操作数为内存变量，但寻址方式为自动增量

"g"             将输入变量放入eax，ebx，ecx，edx中的一个，或者作为内存变量 "X"            操作数可以是任何类型

立即数：
"I"             0-31之间的立即数（用于32位移位指令）
"J"             0-63之间的立即数（用于64位移位指令）
"N"             0-255之间的立即数（用于out指令）
"i"             立即数 
"n"            立即数

匹配：
" 0-9 "         表示用它限制的操作数与某个指定的操作数匹配，去描述"％1"操作
数，那么"%1"引用的其实就是"%0"操作数，注意作为限定符字母的0－9 与指令中
的"％0"－"％9"的区别，前者描述操作数，后者代表操作数。

&                该输出操作数不能使用过和输入操作数相同的寄存器

操作数类型 :      
"="           操作数在指令中是只写的（输出操作数） 
"+"           操作数在指令中是读写类型的（输入输出操作数）

浮点数:
"f"          浮点寄存器
"t"           第一个浮点寄存器
"u"          第二个浮点寄存器
"G"          标准的80387浮点常数
%            该操作数可以和下一个操作数交换位置
                                    
#             部分注释，从该字符到其后的逗号之间所有字母被忽略
*             表示如果选用寄存器，则其后的字母被忽略
```
