### 信号的生命周期？
信号可以从键盘输入，时间片耗尽，硬件异常，软件层面产生，然后信号会存储到未决信号集(pending)中，当进程从内核态转换到用户态时，会检查掩码与未决信号集，如果有信号产生，那么进程会将信号从未决信号集中卸载该信号，那么就调用信号处理函数（如果有注册的话），执行完信号处理函数，那么信号对于该进程的影响将会彻底结束
### 信号的产生方式？
1. 终端上的键盘输入
2. 硬件产生，除以0，非法访存
3. 系统调用函数，kill
4. 软件层面，SIGPIPE，SIGALRM
### 信号处理方式？
1. 忽略信号，缺页异常，子进程结束
2. 用户自定义函数，在产生信号之前向进程中注册信号捕捉函数，在产生信号后，进程会执行已经注册的信号函数
3. 系统默认处理，绝大多数信号系统默认都是去终止该进程
4. SIGKILL，SIGSTOP总是执行系统默认处理方法
### 线程同步几种方式？
1. 使用mutex作为互斥锁
    1. 互斥锁（当一个互斥锁未上锁时，在执行到lock时可以对其上锁并继续执行下文，当一个互斥锁已经上锁，那么该线程会在lock处阻塞，并直到互斥锁释放时继续上锁并执行）
    2. 自旋锁（与互斥锁类似，但是自旋锁并不是通过阻塞和唤醒的方式来处理上锁的，而是通过轮询的方式查看自旋锁是否已经释放）（当此处的锁并不会长期存在，而是在短时间内释放，由于阻塞和唤醒需要一定时间，所以使用自旋锁会比互斥锁效率更高，但是由于自旋锁是通过轮询的方式实现的，所以当一个线程长期自旋在锁处，会很浪费CPU资源）
    3. 读写锁（当写锁已经上锁，那么读锁处阻塞，写锁处阻塞）（当读锁已经上锁，那么读锁可以继续上锁，而写锁阻塞）
2. 使用cond作为条件变量
3. 使用sem作为信号量
### 线程池的作用是什么？
1. 提高程序的并发性：线程池可以管理和调度多个线程，使得程序可以同时执行多个任务，提高了程序的并发性和吞吐量。
2. 优化资源的利用：线程池可以在程序启动时预先创建一定数量的线程，并在需要时分配线程执行任务，避免了频繁创建和销毁线程的开销，优化了系统资源的利用。
3. 提高代码的可维护性：线程池可以将任务的执行和线程的管理分离开来，使得代码结构更加清晰和易于维护。
4. 提高程序的响应速度：由于线程池中的线程已经创建好，当任务到达时，可以直接分配线程执行任务，从而减少了线程创建和销毁的开销，提高了程序的响应速度。
### pthread_cond_signal和pthread_cond_broadcast的区别
pthread_cond_signal:唤醒等待在条件变量上的一个线程
pthread_cond_broadcast:唤醒等待在条件变量上的所有线程，他们会竞争并重新获得锁
### 进程与线程的区别？
1. 进程是资源分配的最小单位，线程是资源调度的最小单位
2. 线程是在进程下运行的，一个进程可以包含多个线程
3. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，而线程是共享进程中的数据的，使用相同的地址空间
4. 同一进程下不同线程间数据容易共享，不同进程间数据很难共享
5. 线程之间没有单独的地址空间，一个线程死掉，整个进程也死掉，而一个进程死掉并不会对另外一个进程造成影响
6. 启动一个线程所需要的开销比启动一个进程的开销要小
### 为什么要字节对齐？
字节对齐是为了优化内存访问和提高处理器效率而采用的一种技术。  
在计算机中，内存是以字节为单位进行分配和管理的，而处理器在访问内存时通常是按字或双字等批量读取数据的。  
如果数据结构没有进行字节对齐，则可能会导致处理器需要进行多次内存访问，这会增加内存带宽和访问延迟，降低程序的执行效率。
### 浮点数为什么会有误差？ 
浮点数在计算机中使用二进制存储，所以当使用浮点数表示十进制小数时，可能会在二进制的表示上舍去循环表示或精度溢出的部分，导致浮点数具有误差
### kill函数的每一个参数的作用？
函数原型  
```cpp
int kill(pid_t pid, int sig);
```
若pid>0那么将sig信号发送到pid对应的进程  
若pid=0那么将sig信号广播到当前进程的进程组中  
若pid=-1那么将sig信号广播到当前进程所有有权发送信号的进程  
若pid<-1那么将sig信号广播到-pid对应的进程组的所有进程  
### 创建进程的步骤？
1. 申请一个空白的PCB和唯一的进程标识号pid
2. 为新进程分配除CPU以外的资源,包括
内存空间;
3. 初始化PCB中的数据项,包括标志信息、状态信息、控制信息等;
4. 将新进程的PCB插入系统的就绪队列。
### 进程切换发生的原因？处理进程切换的步骤？
#### 原因
1. 阻塞式系统调用、虚拟地址异常，导致被中断进程进入等待态。
2. 时间片中断、I/O中断后发现更改优先级进程，导致被中断进程进入就绪态。
3. 终止用系统调用、不能继续执行的异常，导致被中断进程进入终止态。
#### 步骤
1. 保存之前运行的进程上下文
2. 调用准备运行的进程的上下文
3. CPU使用权交接
### 如何检查内存泄露？如果不通过printf,debug等调试方式和编译器报错提示呢？
1. mtrace()函数Linux自带内存检测工具
2. valgrind工具，由内核（CPU模拟环境）以及基于内核的其他调试工具组成
### 系统调用与函数调用的区别？
函数调用是调用函数库中的一段代码块，而系统调用是调用系统内核的服务  
函数调用是与用户程序相联系，而系统调用是操作系统的一个进入点  
函数调用是在用户地址空间执行，而系统调用是在内核地址空间执行  
函数调用的运行时间属于「用户」时间，而系统调用的运行时间属于「系统」时间  
函数调用属于过程调用，开销较小，而系统调用需要切换到内核上下文环境然后切换回来，开销较大
### 可靠信号与不可靠信号的区别？
在信号列表中所有信号值小于32的信号都是不可靠信号，不可靠信号在发送多次而没有被处理时，信号集合不会记录信号发送的次数，只能被算作一次  
在信号列表中所有信号值大于32的信号都是可靠信号，可靠信号在发送多次会加入到队列中，在处理该信号后，会从队列中取出下一个信号，信号不会丢失
### 什么是守护进程？如何查看守护进程？什么是僵尸进程？如何查看僵尸进程？
守护进程是一个在后台运行并且不受任何终端控制的进程    
使用ps -axj指令查看进程，TPGID表示前台进程组，若为-1，则为守护进程
由于当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时该子进程成为僵尸进程  
使用ps -ax指令查看进程，若STAT为Z，则为僵尸进程
