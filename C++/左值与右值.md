## 左值与右值

### 概念

#### 左值

左值是可以取地址的值，或者说是具有名称的值，高级语言中的变量名其实就是汇编语言中的地址，我们通过变量名获取变量值的过程本质上就是通过变量地址获取变量值的过程（const修饰的变量除外）

左值是存在于栈上或常量区上的数据

例如

```c++
int a = 5;
const int val = 4;
```

#### 纯右值

纯右值是不能取地址的值，或者说是没有名称的值

有以下三种可能

- 纯右值可能存放在寄存器上，硬件层面我们无法通过内存地址获取寄存器上的值
- 纯右值可能是机器指令的一部分，机器码层面不允许把指令拆开取值
- 纯右值可能是栈上的匿名变量，编译层面为了安全不允许对这些匿名变量取地址

```c++
//这里的5是机器指令的一部分
int a = 5;
//这里的Node()是存在在栈上的匿名变量，没有名称，所以无法取地址
class Node{};
std::cout << &Node();
```

##### 常见的纯右值有哪些？

```c++
//存在在指令中的字面量
true;7;nullptr;
//算术表达式的结果
1+2;a<b;a&&b;a++;--a;
//lambda表达式
[](int a, int b) -> bool {return a < b;}
//栈上的匿名变量
Node();
```

#### 将亡值

所谓的将亡值就是即将被编译器销毁的值

例如

```c++
std::string getString(){
    std::string str;
    return std::move(str);
}
```

> 在str生命周期内，str是一个左值，过了str生命周期，str不可以取地址，是右值

#### 左值引用

从汇编代码层面看来，左值引用实质上是地址，与指针的区别在于，左值引用必须在定义时初始化，并且不可更改

#### 右值引用

从汇编层面来看，右值引用会把数据存放到栈中，然后再去引用它的地址，所以右值引用实质上也是指针

#### 常量左值引用

从汇编层面看，常量左值引用会把数据存放到栈中，然后再去引用它的地址，这一点和右值引用一致

#### 移动构造

移动构造函数的参数类型是一个右值引用，传入的是一个临时对象或右值

移动构造函数与拷贝构造的区别

1. 移动构造函数的参数是右值引用，而拷贝构造的参数是左值引用
2. 移动构造函数的实现一般会改变被移动对象（也就是右值），移动构造的实现中会将数据的所有权移动给要构造的对象
3. 在实现中，一般拷贝构造会将所有属性的值拷贝一遍，而指针类型会重新申请堆空间，并将堆空间的值拷贝一份（深拷贝）
4. 在实现中，一般移动构造会将所有属性的值拷贝一遍，被移动的对象会放弃所有权，自己的数据会被弃用

```c++
class String{
    char* m_str;
    int m_len;
public:
    String(){
        m_str = nullptr;
        m_len = 0;       
    }
    String(std::string str){
        m_str = new char[str.length()];
        std::strcpy(m_str, str.c_str());
    }
    String(String&& str){
        std::cout << "移动构造" << std::endl;
        m_str = str.m_str;
        str.m_str = nullptr;
        str.m_len = 0;
    }
    String(const String& str){
        std::cout << "拷贝构造" << std::endl;
        m_str = new char[str.m_len];
        std::strcpy(m_str, str.m_str);
        m_len = str.m_len;
    }
    char* getString(){
        return m_str;
    }
    int getLength(){
        return m_len;
    }
};
```



#### 引用折叠

