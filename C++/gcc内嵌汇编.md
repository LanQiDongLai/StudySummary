### gcc内嵌汇编

示例

```cpp
int return4(){
    int res;
    __asm__ __volatile__(
        "movl $4, %0\n\
        "
        :"=m"(res)
        :"%0"
    );
    return res;
}
```

格式

```cpp
__asm__ [__volatile__](
    "asm"									//汇编代码指令部分
    :"{m}{k}"(output), "{m}{k}"(output), ...//输出存储器
    [:"{k}"(input), "{k}"(input), ...]		//输入存储器（可选）
    [:["{r}", "{r2}", ..., "{rn}"]]			//被修改的存储器列表（可选）
)
```

\_\_asm\_\_ 标识后面的代码是内嵌汇编

\_\_volatile\_\_ 表示编译器不要优化内嵌汇编代码

对于{m}，和{k}的值，具体[详见](https://zhuanlan.zhihu.com/p/578286784)

```text
通用寄存器：
"a"               将输入变量放入eax
"b"               将输入变量放入ebx
"c"               将输入变量放入ecx
"d"               将输入变量放入edx
"s"               将输入变量放入esi
"d"               将输入变量放入edi
"q"               将输入变量放入eax，ebx，ecx，edx中的一个
"r"               将输入变量放入通用寄存器，也就是eax，ebx，ecx，edx，esi，edi中的一个
"A"              把eax和edx合成一个64 位的寄存器(use long longs)

内存：

"m"              内存变量
"o"              操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址
"V"              操作数为内存变量，但寻址方式不是偏移量类型
" "              操作数为内存变量，但寻址方式为自动增量

"g"             将输入变量放入eax，ebx，ecx，edx中的一个，或者作为内存变量 "X"            操作数可以是任何类型

立即数：
"I"             0-31之间的立即数（用于32位移位指令）
"J"             0-63之间的立即数（用于64位移位指令）
"N"             0-255之间的立即数（用于out指令）
"i"             立即数 
"n"            立即数

匹配：
" 0-9 "         表示用它限制的操作数与某个指定的操作数匹配，去描述"％1"操作
数，那么"%1"引用的其实就是"%0"操作数，注意作为限定符字母的0－9 与指令中
的"％0"－"％9"的区别，前者描述操作数，后者代表操作数。

&                该输出操作数不能使用过和输入操作数相同的寄存器

操作数类型 :      
"="           操作数在指令中是只写的（输出操作数） 
"+"           操作数在指令中是读写类型的（输入输出操作数）

浮点数:
"f"          浮点寄存器
"t"           第一个浮点寄存器
"u"          第二个浮点寄存器
"G"          标准的80387浮点常数
%            该操作数可以和下一个操作数交换位置
                                    
#             部分注释，从该字符到其后的逗号之间所有字母被忽略
*             表示如果选用寄存器，则其后的字母被忽略
```

