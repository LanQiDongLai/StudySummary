### 基本语言

#### 说一下C++和C的区别

1. C++是支持面向对象编程，而C是一个过程化编程语言
2. C++拥有大量的标准库，使用标准库可以简化开发工作
3. C++拥有更高级的内存管理，包括RAII，智能指针
4. C++开发领域不同，在后端开发，游戏开发，图像处理，人工智能方面拥有更广泛的前景，而C更适合底层操作系统，嵌入式的开发

#### 说一下C++中static关键字的作用

1. 静态局部变量，其值会存储在程序的静态存储区域中，在退出函数之后不会销毁，而是一直保持
2. 静态成员函数和变量，该值或该方法的全为类所管辖，是所有该类实例化的对象所共享
3. 静态全局函数和变量，在命名空间内或文件作用域内声明的静态类只在当前编译单元中可见

#### 说一说c++中四种cast转换

1. 静态转换(static_cast):可以将基础类型像话转化，或将指针转化为不同的类型的指针
2. 动态转换(dynamic_cast):会检查继承层次中继承关系（检查虚函数表），进行安全的向下类型转化，如果不安全，会返回空指针
3. 常量转化(const_cast):从常量对象的指针或引用中删除常量修饰符
4. 重新解释转换(reinterpret_cast):最不安全的之中转换，它允许在两个完全不相关的类型之间进行转换

#### 请说一下C/C++ 中指针和引用的区别？

1. 定义不同
2. 初始化不同，引用必须要初始化必须先初始化到一个存在的变量
3. 是否可以为空值
4. 是否可以改变，引用不会改变自己所引用的变量
5. 在传递参数的时候，引用传递更为简介
6. 引用的主要目的是为了防止复制对象，和语法的简洁性，而指针更倾向于实现各种数据结构

#### 请你说一下你理解的c++中的smart pointer四个智能指针

1. unique_ptr(独占指针): 在智能指针对象生命周期结束的时候，会自动释放所指向的内存，其包含内存的所有权，无法被复制到另个智能指针对象上，只能通过`std::move()`和移动语义来转移到另一个独占指针上
2. shared_ptr(共享指针):允许多个指针共享相同的资源，他们会共享一个引用计数来跟踪资源的引用计数，每当复制一次，就会多一次引用计数，每当一个共享指针对象释放的时候，就会少一次引用计数，当引用计数为0时，内存才会释放，要注意循环引用而导致的内存泄漏的情况
3. weak_ptr(弱指针):它是shared_ptr的辅助类，不会增加资源的引用计数，可以避免循环引用的问题
4. auto_ptr(已弃用):因为拷贝语义和C++标准的语义不同，所以已经弃用，可以使用`std::unique_ptr`替代，通过移动语义代替拷贝语义

#### 请回答一下数组和指针的区别

1. 数组在本作用域中包含了数组的大小信息，在编译器眼中他是一个数组类型的数据
2. 一旦将数组通过函数参数传递到另一个作用域中，数组变量会弱化成一个指针，失去大小长度信息
3. 数组的大小会在编译时确定，而指针可以动态分配内存

#### 请你来说一下函数指针

函数指针存储了全局函数的地址，通过函数指针可以调用所指向的函数

#### 请你来说一下fork函数

1. fork是Unix或类Unix系统的一个系统调用，可以创建一个新的进程，并且该进程为当前进程的子进程，其复制了父进程的内存页表，文件描述符，寄存器值
2. fork在父进程中返回为子进程的pid，而子进程中返回为0，通过返回值，让子进程和父进程进入不同的分支，完成不同的功能
3. 父进程与子进程并发执行，通过调度算法决定哪个先执行已经执行多长时间，宏观来看，似乎两个进程在同时执行

#### 请你来说一说C++函数栈空间的最大值

C++函数栈的最大值受编译器和系统共同的影响，通常在几MB到数百MB之间

可以通过更改ulimit命令来查看和调整栈的大小

在编写代码时如果一个数据或数据结构需要长期保持，尽量使用堆内存而不是栈内存

#### 请你说说C语言是怎么进行函数调用的？

1. 参数传递
2. 栈帧创建，将函数参数入栈，函数的返回地址入栈，需要保存的寄存器状态入栈
3. 控制权转移，PC指针转移
4. 执行函数体
5. 返回值传递，传递到rax寄存器中
6. 栈帧销毁，恢复rsp所指向的位置，即函数执行之前栈寄存器的地址
7. 控制权返回，PC指针返回到函数调用的下一条指令

#### 请你回答一下C++类内可以定义引用数据成员吗？

可以但是必须在初始化列表中初始化，并且在初始化列表初始化之后，不允许再重新引用到其他变量

### 容器与算法

#### 请你来介绍一下STL的`allocator`

STL中的`allocator`是一种用于管理动态内存分配和释放的抽象机制。它是C++标准的一个组件，用于各种容器类的动态分配内存和释放内存。`allocator`负责将内存的分配和对象的构造与销毁分离开，值有助于提高性能和安全性。

在以往的C++实现中，`allocator`采用的是内存池技术，该技术中维护了一个链表，链表中每个节点指向了一组不同单元大小的内存块，allocator会根据要分配的内存大小来选择其中的一个内存块，并标记其已经使用，当释放资源的时候，将其标记为未使用，这样防止频繁的调用系统调用来申请内存

在现代C++实现中，放弃了原来的内存池技术，而是采用直接内存分配，因为操作系统的内存管理机制已经足够高效，并且内存池技术存在内存碎片

#### vector与list区别

1. 底层数据结果
2. 插入与删除时间复杂度
3. 随机访问
4. 内存分配
5. 使用场景，vector适合高效随机访问和末尾的插入和删除，list适合频繁的插入和删除元素
6. 删除和插入是否会使得迭代器失效

#### 请你来说一下STL中迭代器的作用，有指针为何还要迭代器

1. **容器隐藏**：迭代器隐藏了底层容器的实现细节，使得容器的具体数据结构对用户来说是透明的。这提供了更好的封装和抽象。

2. **容器安全性**：迭代器提供了范围检查和边界检查，防止了越界访问和非法内存访问。指针通常不提供这种安全性。
3. **迭代器的一致性接口**：通过定义统一的移动方法和访问元素的方法，STL算法可以同时为不同的容器服务

#### 编译与底层

#### 请你来说一下一个C++源文件从文本到可执行文件经历的过程？

1. 预处理的头文件与宏替换
2. 编译成汇编
3. 汇编成机器码
4. 链接成可执行文件

#### 请你来回答一下include头文件的顺序以及双引号””和尖括号的区别？

双引号会优先搜索当前源文件目录下的头文件

尖括号会优先搜索编译器环境变量中的系统库头文件目录

### noexcept是什么，干什么的

noexcept告诉编译器这里不会抛出异常，帮助编译器优化，但是如果真的抛出了异常，那么程序将会终止

### C++中空类型为什么会是1字节大小

如果一个对象的字节大小为0字节，那么两个不同对象在栈区定义的话或者结构体中存在一个元素的变量长度为0的话，就会两个对象的地址空间为相同的值，编译器为了区分他们，所以空类型至少有一个字节大小
