### 系统内存

#### 请你来回答一下什么是memory leak，也就是内存泄漏

内存泄漏指的是程序分配了一块控件，在不需要的时候没有正确的释放，占用系统资源而无法被其他进程使用

1. 申请未释放
2. 未关闭的文件和资源
3. 临时缓存不再使用未释放

#### 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？

malloc是glibc中封装的函数调用，它使用了brk和mmap系统调用

当malloc申请的内存大于128KB的时候，malloc会使用mmap系统调用

当malloc申请的内存大小小于等于128KB的时候，malloc会使用brk系统调用

brk申请内存时会将堆顶指针向高字节移动，或者使用堆中空闲的内存块

mmap会从文件映射区中分配内存

当brk中分配的内存释放的时候，程序并不会立即将内存返还给操作系统，而是设置空闲，当下次申请的时候可以直接使用，这样效率高，但是在申请和释放容易造成内存碎片

当mmap中分配的内存释放的时候，会将内存返还给操作系统管理，效率低，但是不会出现内存碎片

#### 哪些内存可以回收

内存页分为文件页和匿名页，文件页是从内存中缓存的文件数据，可以随时释放，如果有写入的脏块需要先写入，匿名页通过swap来将不常使用的数据转换到swap中，需要时再取回来

#### 回收内存的几种方式

后台内存回收、直接内存回收、OOM

后台内存回收：内存存在三个阈值将内存大小分为四个范围，分别是内存充足、内存分配正常、内存压力大、内存基本耗尽，在操作系统中这三个阈值是可设置的，当进入内存压力大时，启动后台内存回收，当进入内存充足时，后台内存回收才会停止。这种回收是异步的，不会阻塞进程的运行

直接内存回收：当进入内存基本耗尽的时候，会启动直接内存回收，这种内存回收是同步的，会阻塞进程的运行，也就是系统时不时会发生卡顿

OOM：当内存基本耗尽，直接内存回收也无法尽快的腾出足够的内存，那么会触发OOM机制，强制终止占用内存过大进程

#### 如何保护进程不被OOM杀死

1. 每个进程都有一个参数，参数与进程所占内存的大小之间进行加权运算，取得的最终分数作为评判该内存是否可以被OOM杀死的依据，可以适当的降低参数值防止被杀死
2. 适当的提高三个内存阈值，让内存管理器更快的感受内存压力，启动后台内存回收
3. 调节内存使用中匿名页与文件页内存回收的优先比例，建议优先回收文件页，匿名页回收涉及磁盘的频繁读写，容易造成性能下降

#### Swap分区的作用

当内存

#### 请你来说一下什么时候会发生段错误

当进程尝试访问为分配给他的内存区域时会发生段错误

具体有以下几种

1. 访问空指针
2. 访问越界数组
3. 栈溢出
4. 非进程所属内存的访问
5. 进程中只读段的修改
6. 使用已经释放的内存

#### 请你回答一下如何判断内存泄漏？

1. 通过`top`命令来查看一个进程的内存使用情况，如果在不断地增长，那么很有可能发生内存泄漏
2. 通过内存检查器，在Linux中可以安装valgrind来检查进程是否发生内存泄漏

### 线程与进程

#### 你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的

进程与线程是操作系统中重要的概念，用于管理和执行计算机程序。它们都是并发编程的基本组成部分，但具有不同的特性和用途。

1. **进程（Process）**：
   - 进程是一个独立的执行单元，拥有独立的内存空间、资源和程序计数器。
   - 进程之间相互隔离，一个进程的崩溃通常不会影响其他进程。
   - 进程的创建和销毁通常比较耗费系统资源，因为它需要分配独立的内存空间。
   - 进程间通信（IPC，Inter-Process Communication）相对复杂，需要使用特殊的机制如管道、消息队列、共享内存等。

2. **线程（Thread）**：
   - 线程是在进程内部的执行单元，共享进程的内存空间和资源。
   - 线程之间更容易创建和销毁，因为它们共享相同的内存空间。
   - 线程之间的通信更容易，因为它们可以直接访问相同的内存。
   - 由于共享资源，线程之间需要更小心地处理同步问题，以避免竞态条件（Race Condition）和死锁（Deadlock）等问题。

为什么要有进程和线程以及它们的区别：

- **并发性和性能优化**：进程和线程允许程序在多个任务之间并发执行，从而提高程序的性能。线程通常比进程更轻量级，更适合处理多个并发任务，因此可以更好地利用多核处理器。

- **资源共享**：线程可以共享相同的内存空间，这使得数据在不同线程之间更容易共享，从而提高了程序的效率。

- **模块化和组织**：进程和线程使程序更容易组织成多个可管理的模块，每个模块负责不同的任务。

关于同步：

- **进程同步**：进程间通信需要额外的同步机制，如信号量、互斥锁等，以确保多个进程之间的数据访问不会导致冲突。

- **线程同步**：线程共享相同的内存，因此需要更小心地处理同步问题。线程同步通常使用互斥锁、条件变量、信号量等机制来协调多个线程之间的操作，以避免竞态条件和死锁。

总结：进程和线程都是实现并发执行的方式，但它们在资源隔离、创建销毁开销、通信复杂度等方面有不同的特点。选择使用进程还是线程取决于应用程序的需求和性能优化目标。无论是进程还是线程，都需要小心处理同步问题，以确保多个执行单元能够正确协同工作。

#### 进程中的通讯方式

1. **管道**：又分为命名管道和匿名管道，**命名管道**存在于文件系统中，当有写入的操作才可以读取，如果没有读取操作，那么写会阻塞，同理，如果没有写操作，读会阻塞。**匿名管道**存在于父子进程之间，父进程先创建好管道的出入口，然后子进程复制父进程的文件描述符表，最后父子进程关掉读端或写端，然后父进程就可以读取或写入管道，子进程可以写入或读取管道，这样父子进程之间就可以通讯
2. **消息队列**：消息队列是存储在内核中的消息链表，这意味着，发送进程是的发送函数不是阻塞的，信息存储在内核中，接受进程可以通过标识，从中读取数据，但是消息体大小有限制，并且频繁的交互存在用户态和内核态切换的开销
3. **共享内存**：不同的进程拿出一段虚拟页表出来，共同指向同一内存区域，这样一个进程在读写之后，另一个进程可以直接通过指针读取数据，但是没有通知机制使得读写操作互斥，容易出现竞争
4. **信号量**：信号量用于数据的同步，信号量存在两个操作，第一种是P操作，表示获取资源，第二种是V操作，表示释放资源，当资源量为0的时候，P操作会阻塞，通过信号量，可以控制资源的获取，也可以当作互斥锁设置代码临界区
5. **信号**：信号是异步的通信机制，当进程受到信号通知的时候，会暂停当前代码的执行，转而执行注册的信号处理函数（如果有注册的话），信号通知可以来源于硬件（键盘Ctrl-C Ctrl-Z），软件（函数调用kill raise），系统内核（段错误，终止abort）
6. **网络通讯**：唯一一个可以跨越系统的通讯，通过网络不同的协议，发送和接受数据

#### 进程或线程锁有几种？

1. 互斥锁
2. 自旋锁
3. 读写锁
4. 写优先锁
5. 读写队列
6. 乐观锁

#### 死锁的条件有哪些？如何避免死锁？

1. 互斥条件
2. 持有并等待条件
3. 不可剥夺条件
4. 循环等待条件

根据上面四点，我们只要打破其中一个条件就可以了，我们最常可以改变的是最后一点，将不同的线程或进程所请求资源的次序应当相同，避免两边同时拥有不同的资源

### 调度算法

#### 进程调度算法

1. 先来先服务（FCFS）：谁先启动，谁先执行，并且一直执行到结束。缺点：长任务会一直占用CPU资源，后来任务饥饿
2. 最短作业优先（SJF）：短作业优先执行，并且一直执行到结束。缺点：过多的短任务会一直占用CPU资源，长任务饥饿
3. 高响应比优先（HRRN）：会将任务时长和已等待时长一起考虑，算出优先值，高优先值先运行，并且一直执行到结束。缺点：当长任务在执行的时候，新来的任务不能得到好的响应（没有时间片共同的缺点）
4. 时间片轮转（RR）：当一个任务的运行时间片耗尽的时候，那么挂起任务，转而执行其他任务。缺点：不同任务拥有相同的优先级
5. 最高优先级（HPF）：每个任务都有一个优先级标识，取出最高优先级的任务执行。缺点：低优先执行不到任务
6. 多级反馈队列（MFQ）：结合时间片轮转调度算法和最高优先级调度算法，设计出多级反馈队列调度算法，新的进程进入第一个队列，执行最短的时间片长度，如果没有执行完，那么放入到下一个队列中。只有高优先级的队列为空的时候，才会执行低一级的队列。这样短任务优先执行完，长任务虽然会在队列中等待，但是每次执行的时间片变长

多级反馈队列算法图示

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt="多级反馈队列" style="zoom:80%;" />

#### 内存页面置换算法

1. 最佳页面（OPT）：最理想的算法结果，考虑置换未来最不常用的页面，但是未来不可预测，这个只是对其他算法效率的评估
2. 先入先出（FIFO）：谁先加载到页表中，谁先被置换。缺点：只考虑了寿命，没有考虑使用频率
3. 最近最久未使用（LRU）：查找页面最最近最少被读取或写入的，并置换。缺点：算法不好设计，复杂度大
4. 时钟页面（Lock）：每个页面多一个访问位，并且存在一个时钟指针，当有新的页面要插入时，指针会向下遍历，将访问位为1的修改为0，直到找到原本访问位为0的，并置换
5. 最不常用（LFU）：每个页面多一个访问计数，每次访问都增加1，找到最小的访问计数并替换。缺点：没有考虑时间对频率的效益，最新加入的节点最少访问所以经常被替换，相反越旧的页面就算最近没有被访问也不会被替换，并且该访问计数硬件实现上成本较高

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法" style="zoom:80%;" />

#### 磁盘调度算法

1. 先来先服务（FCFS）：对于写入或访问操作直接按照顺序执行。缺点：访问碎片化，性能低下
2. 最短寻道时间优先（SSF）：寻找序列中距离当前磁头最近的一个。缺点：容易造成远磁道饥饿
3. 扫描（Scan）：从磁道开头扫描到磁道结尾，遇到终点就转弯反向扫描
4. 循环扫描（CSAN）：从磁道开头磁道，遇到终点，直接跳到开头重新扫描
5. LOOK与C-LOOK：该算法与扫描与循环扫描的区别是，只从最近请求和最远请求之间移动

### 文件系统

